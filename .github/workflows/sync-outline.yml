name: Sync to Outline

on:
  push:
    branches: [main]
    paths:
      - 'docs/**/*.md'
  workflow_dispatch:

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      
      - name: Install dependencies
        run: pip install requests pyyaml
      
      - name: Bypass Cloudflare
        uses: xiaotianxt/bypass-cloudflare-for-github-action@v2.0.1
        with:
          cf_account_id: ${{ secrets.CF_ACCOUNT_ID }}
          cf_zone_id: ${{ secrets.CF_ZONE_ID }}
          cf_api_token: ${{ secrets.CF_API_TOKEN }}
      
      - name: Aguardar propagação Cloudflare
        run: sleep 10
      
      - name: Sync documents to Outline
        env:
          OUTLINE_URL: https://wiki.zaz.vc
          OUTLINE_TOKEN: ${{ secrets.OUTLINE_API_TOKEN }}
          COLLECTION_00_E: e305c77a-1c2e-4b30-9e03-b4009151257b
          COLLECTION_00_O: dc5d8afd-bba7-4a5b-a193-3c19668c3f44
          COLLECTION_01: 7179e7b0-8037-4979-a030-816e2394355d
        run: |
          python << 'EOF'
          import os
          import re
          import yaml
          import requests
          from pathlib import Path

          OUTLINE_URL = os.environ['OUTLINE_URL']
          TOKEN = os.environ['OUTLINE_TOKEN']
          HEADERS = {
              'Authorization': f'Bearer {TOKEN}',
              'Content-Type': 'application/json'
          }

          COLLECTIONS = {
              'docs/00_E': os.environ['COLLECTION_00_E'],
              'docs/00_O': os.environ['COLLECTION_00_O'],
              'docs/01': os.environ['COLLECTION_01'],
          }

          def get_collection(filepath):
              for prefix, coll_id in COLLECTIONS.items():
                  if filepath.startswith(prefix):
                      return coll_id
              return None

          def parse_frontmatter(content):
              if not content.startswith('---'):
                  return {}, content
              parts = content.split('---', 2)
              if len(parts) < 3:
                  return {}, content
              try:
                  fm = yaml.safe_load(parts[1])
                  body = parts[2].strip()
                  return fm or {}, body
              except:
                  return {}, content

          def get_title(fm, body):
              if 'nome' in fm:
                  return fm['nome']
              match = re.search(r'^#\s+(.+)$', body, re.MULTILINE)
              if match:
                  return match.group(1)
              return 'Sem título'

          def get_numeric_prefix(nome):
              """
              Extrai prefixo numérico do nome.
              
              Exemplos:
                00_E_1_2_Metodo → 00_E_1_2
                00_E_Epistemologia → 00_E
                00_O_1_1_Metodo_Epistemologico → 00_O_1_1
                01_1_02_Segmentos → 01_1_02
              """
              parts = nome.split('_')
              prefix = []
              for part in parts:
                  # Número puro (1, 02, 10, etc)
                  if part.isdigit():
                      prefix.append(part)
                  # Código de 2 chars começando com dígito (00, 01) ou letra única (E, O)
                  elif len(part) <= 2 and (part[0].isdigit() or (len(part) == 1 and part.isupper())):
                      prefix.append(part)
                  else:
                      # Encontrou parte descritiva, para aqui
                      break
              return '_'.join(prefix)

          def find_parent_id(nome, doc_map):
              """
              Encontra documento pai baseado no prefixo numérico.
              
              Regra: Pai = documento existente cujo prefixo numérico é
                     o ancestral mais próximo do prefixo atual.
              
              Exemplos:
                00_E_1_2_Metodo (prefixo 00_E_1_2)
                  → tenta 00_E_1 (não existe)
                  → tenta 00_E (existe: 00_E_Epistemologia) ✓
                
                00_O_1_1_1_Definir_Objeto (prefixo 00_O_1_1_1)
                  → tenta 00_O_1_1 (existe: 00_O_1_1_Metodo_Epistemologico) ✓
              """
              my_prefix = get_numeric_prefix(nome)
              if not my_prefix:
                  return None
              
              prefix_parts = my_prefix.split('_')
              
              # Tenta cada ancestral (do mais próximo ao mais distante)
              for i in range(len(prefix_parts) - 1, 0, -1):
                  ancestor_prefix = '_'.join(prefix_parts[:i])
                  
                  # Busca documento cujo prefixo seja EXATAMENTE o ancestral
                  for doc_nome, doc_id in doc_map.items():
                      if doc_nome != nome:
                          doc_prefix = get_numeric_prefix(doc_nome)
                          if doc_prefix == ancestor_prefix:
                              return doc_id
              
              return None

          def create_document(title, text, collection_id, parent_id=None):
              data = {
                  'title': title,
                  'text': text,
                  'collectionId': collection_id,
                  'publish': True
              }
              if parent_id:
                  data['parentDocumentId'] = parent_id
              
              resp = requests.post(
                  f'{OUTLINE_URL}/api/documents.create',
                  headers=HEADERS,
                  json=data
              )
              if resp.status_code == 200:
                  return resp.json()['data']
              else:
                  print(f"  ❌ Erro ao criar: {resp.text}")
                  return None

          def update_document(doc_id, title, text):
              resp = requests.post(
                  f'{OUTLINE_URL}/api/documents.update',
                  headers=HEADERS,
                  json={
                      'id': doc_id,
                      'title': title,
                      'text': text,
                      'publish': True
                  }
              )
              if resp.status_code == 200:
                  return resp.json()['data']
              else:
                  print(f"  ❌ Erro ao atualizar: {resp.text}")
                  return None

          def search_document(title, collection_id):
              resp = requests.post(
                  f'{OUTLINE_URL}/api/documents.search',
                  headers=HEADERS,
                  json={
                      'query': title,
                      'collectionId': collection_id
                  }
              )
              if resp.status_code == 200:
                  results = resp.json().get('data', [])
                  for r in results:
                      if r['document']['title'] == title:
                          return r['document']['id']
              return None

          # Main
          print("=== Sincronizando com Outline ===\n")

          docs = []
          for md_file in Path('docs').rglob('*.md'):
              filepath = str(md_file)
              collection_id = get_collection(filepath)
              if not collection_id:
                  print(f"⚠️  Ignorando {filepath} (sem collection mapeada)")
                  continue
              
              content = md_file.read_text(encoding='utf-8')
              fm, body = parse_frontmatter(content)
              title = get_title(fm, body)
              
              docs.append({
                  'filepath': filepath,
                  'nome': fm.get('nome', title),
                  'title': title,
                  'text': body,
                  'collection_id': collection_id,
                  'outline_id': fm.get('outline_id')
              })

          # Ordena por tamanho do prefixo (pais primeiro)
          docs.sort(key=lambda d: len(get_numeric_prefix(d['nome'])))

          doc_map = {}

          # Primeira passada: coleta IDs existentes
          for doc in docs:
              if doc['outline_id']:
                  doc_map[doc['nome']] = doc['outline_id']
              else:
                  existing_id = search_document(doc['title'], doc['collection_id'])
                  if existing_id:
                      doc_map[doc['nome']] = existing_id
                      doc['outline_id'] = existing_id

          # Segunda passada: cria/atualiza
          created = 0
          updated = 0

          for doc in docs:
              print(f"Processando: {doc['filepath']}")
              prefix = get_numeric_prefix(doc['nome'])
              print(f"  Prefixo: {prefix}")
              
              if doc['outline_id']:
                  result = update_document(doc['outline_id'], doc['title'], doc['text'])
                  if result:
                      print(f"  ✅ Atualizado")
                      updated += 1
              else:
                  parent_id = find_parent_id(doc['nome'], doc_map)
                  if parent_id:
                      parent_nome = [k for k, v in doc_map.items() if v == parent_id][0]
                      print(f"  Pai: {parent_nome}")
                  else:
                      print(f"  Pai: (root)")
                  
                  result = create_document(
                      doc['title'],
                      doc['text'],
                      doc['collection_id'],
                      parent_id
                  )
                  if result:
                      doc_map[doc['nome']] = result['id']
                      print(f"  ✅ Criado (id: {result['id']})")
                      created += 1

          print(f"\n=== Resumo ===")
          print(f"Criados: {created}")
          print(f"Atualizados: {updated}")
          print(f"Total: {len(docs)}")
          EOF
